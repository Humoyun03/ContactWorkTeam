package uz.gita.contactworkteam.data.repositoryimport android.util.Logimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.flow.Flowimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.flowOnimport retrofit2.Responseimport uz.gita.contactworkteam.data.mappers.toDataimport uz.gita.contactworkteam.data.mappers.toEntityimport uz.gita.contactworkteam.data.source.local.room.dao.ContactDaoimport uz.gita.contactworkteam.data.source.remote.api.ContactApiimport uz.gita.contactworkteam.data.source.remote.request.ContactAddRequestimport uz.gita.contactworkteam.domain.models.ContactParamimport uz.gita.contactworkteam.domain.repository.AppRepositoryimport uz.gita.contactworkteam.utils.myTimberimport javax.inject.Injectclass AppRepository @Inject constructor(    private val contactDao: ContactDao,    private val api: ContactApi) : AppRepository {    private lateinit var response: Response<String>    override fun getAllContacts(): Flow<Result<List<ContactParam>>> = flow {        Log.d("TTT", "getAllContacts: ")        emit(Result.success(contactDao.getAllContacts().map { it.toData() }))    }        .catch { emit(Result.failure(it)) }        .flowOn(Dispatchers.IO)    override fun addContact(contactParam: ContactParam): Flow<Result<Unit>> = flow {        Log.d("TTT", "addContact: $contactParam")        emit(Result.success(contactDao.addContact(contactParam.toEntity())))    }        .catch { emit(Result.failure(it)) }        .flowOn(Dispatchers.IO)    override fun editContact(contactParam: ContactParam): Flow<Result<Unit>> = flow {        emit(Result.success(contactDao.updateContact(contactParam.toEntity())))    }        .catch { emit(Result.failure(it)) }        .flowOn(Dispatchers.IO)    override fun deleteContact(contactParam: ContactParam): Flow<Result<Unit>> = flow {        Log.d("TTT", "deleteContact: $contactParam")        emit(Result.success(contactDao.deleteContact(contactParam.toEntity())))    }        .catch { emit(Result.failure(it)) }        .flowOn(Dispatchers.IO)    override fun insertAllContactsToAPi(): Flow<Result<String>> = flow {        val contactList = contactDao.getUnSendContacts()        myTimber("inserting")        contactList.forEach {            response = api.addContact(ContactAddRequest(it.firstName, it.lastName, it.phone))        }        if (response.isSuccessful && response.body() != null) {            myTimber("succes result repos")            contactList.forEach {                it.isSend = true            }            emit(Result.success(response.message()))        }    }.catch {  }.flowOn(Dispatchers.IO)}